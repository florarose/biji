# 服务发现中间件
  Eureka  Consul Zookeeper
## Eureka
## 背景   
  - 传统模式下,我们会在写代码的时候使用提供了Rest Api 或者 Thrift Api 的服务,为了完成一次服务请求,我们的代码需要确定服务实例的网络位置(   
  包括IP地址和端口)。项目一般运行在物理硬件上，服务实例的网络地址相对固定。可能会设置有一个固定的配置文件，代码从中读取变更的网络地址。
  - 现代模式下,项目都是基于云，服务实例的网络位置都是动态分配的，在一个微服务应用中，服务实例运行环境是动态变化的。实例网络地址也是动态变化的，   
    因此，客户端为了访问服务必须使用服务发现机制。在使用过程中可能由于扩展、失效和升级等等需求，造成服务实例的经常变动。
  - 综上所述，传统模式下,通过硬编码实现服务提供者有一定的局限性，比如使用场景，无法动态的伸缩灯。因此，客户端代码需要一种更加复杂的服务发现机制。
## 两类服务发现模式  客户端发现和服务端发现
### 一 客户端发现
  1. 在客户端发现模式下，客户端负责决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端从一个服务注册服务中查询，其实包含所有可用服务实例的库。   
    客户端使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。（客户端向服务注册表发起请求，选择可用实例，发出请求）
  2. 服务实例的网络位置是在启动时注册到服务注册表中，并且在服务终止时从注册表中删除。服务实例注册信息一般使用的是心跳机制来定期刷新。
  3. Eureka 是一个服务注册表，为服务实例注册管理和查询可用实例提供了Rest Api接口。
  4. 客户端模式的缺点： 需要针对不同的编程语言注册不同的服务，在客户端需要为每一种语言开发不同的服务发现逻辑。
  5. 客户端模式的优点： 该模式相对较简单，除了服务注册表，没有其他改变的因素。而且，由于客户端知道可用的服务实例，因此它可以做出智能的，
     特定于应用程序的负载平衡决策，例如使用一致性哈希。
### 二 服务端发现
  1. 客户端通过路由转发请求，路由器向服务注册表发出请求，转发次请求到某个可用实例。
## 服务注册表
  1. 服务注册表是服务发现的主要部分。它是一个包含服务实例网络位置的数据库。服务注册表提供一种注册管理API和请求API。服务实例使用注册管理API来实现注册和注销。     
     服务注册表需要高可用且实时更新，客户端可以缓存从服务注册表获得的   网络地址，但是，该信息最终会过时,客户端也无法发现服务实例。   
     因此，服务注册表由若干使用复制协议保持同步的服务器构成。
  2. Netflix Eureka 就是一个很好的服务注册表，提供了Rest Api注册和请求服务实例。服务实例使用Post请求注册网络地址,每30秒必须使用Put方法更新注册表，   
     使用http delete 请求或者实例超时来删除注册。如您所料，客户端可以使用http get 请求接受注册服务实例信息。
  3. Netflix 通过在每个AWS EC2域运行一个或者多个Eureka服务实现高可用性，每个Eureka服务器都运行在拥有弹性IP地址的Ec2实例上。DNS text记录用于存储   
     Eureka集群配置，存放从可用域到一系列Eureka服务器网络地址的列表。当Eureka服务启动时，向Dns请求接受Eureka集群配置，确认同伴位置，给自己分配一个   
     未被使用的弹性Ip地址。
  4. Eureka客户端—服务和服务客户端—向DNS请求发现Eureka服务的网络地址，客户端首选使用同一域内的服务。如果没有可用服务，客户端会使用另外一个可用域的Eureka服务。
## 服务实例如何在注册表中注册的
  1. 注册方式:
  - 服务实例自己注册，称为自注册模式;
  - 为其他系统提供服务实例管理的，称为第三方注册模式。
  2. 自注册方式：
  - 服务实例负责在服务注册表中注册和注销。在某些情况下，一个服务实例也需要发送心跳来保证注册信息不会过时。
  - Eureka Client 就是自注册的实现。 Eureka 客户端负责处理服务实例的注册和注销。 Spring Cloud项目实现了包括服务发现在内的各种模式，   
    可以轻松地在Eureka中自动注册服务实例。 您只需使用@EnableEurekaClient注释对Java Configuration类进行注释。
  - 优点：相对简单，不需要其他系统功能。
  - 缺点：把服务实例和服务注册表关联起来。必须在每种编程语言内和框架内部实现注册代码。
  3. 第三方注册模式
  - 某个系统模块负责处理注册和注销。例子Kubernetes
## 一、考虑
  1. 设计需要考虑的因素
  2. 为什么如此设计
  3. 可以优化的地方 
## 二、设计问题
  1. 注册中心，需要考虑的问题  
  - 第一: 存储问题需要考虑 , 注册中心的作用是用来存储各个服务器的地址端口等信息；   
  - 第二: 存储的方式，是各系统推送数据还是存储器主动拉取数据？频率如何考虑？通过什么通信方式，是socket通信？   
  - 第三： 注册服务的准确性、实时性、可靠性如何考虑？   
  - 第四： 服务过多，压力如何解决？
  2. 注册步骤   
   ![image](https://yqfile.alicdn.com/a8a41ec4f46c5c108b2e525f1905bad3ffe724fe.png)   
## 三、定义
  - Eureka 由两个组件组成：Eureka服务器和Eureka客户端。Eureka 服务器用作服务注册服务器。   
  - Eureka 客户端是一个 java 客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。   
  - Netflix 在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。  
## 四. 自我保护机制
   - Eureka 各个节点是平等的，没有ZK中角色的概念。即使N-1个节点挂掉也不会影响其他节点的正常运行。
    自我保护机制是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。
  1. 目的   
         默认情况下，如果Eureka Server 在一定时间内（默认的是90秒）没有接收到某个服务实例的心跳，Eureka Server将移出该实例。
     在网络分区故障发生时，微服务与Eureka Server之间无法正常通信，但是微服务本身是正常运行的，这种情况下，是不应该移出该微服务实例的，
     所以引入了自我保护机制。是一种对网络异常的安全保护措施。
  2. 实现
        Eureka协议要求客户端永久离开时执行明确的注销操作。比如，在提供的java客户端中，就是通过shutdown()方法完成的。任何连续3次心跳续订失败   
     的客户端将被视为不正常的终止，并且将由后台驱逐过程住处。 如果Eureka server结点在15分钟之内超过85%的客户端节点都没有正常的心跳，
     那么Eureka就认为客户端与注册中心出现了网络故障，当前结点自动进入自我保护机制。在保护机制下，Eureka server的工作状态：   
  - 不在从注册列表中移出因为长时间没有收到心跳而应该过期的服务实例；
  - 仍然可以接受新服务的注册和查询请求，但是不会被同步到其他节点上，保证当前节点依然可用；
  - 当网络稳定时，当前Eureka Server新的注册信息会被同步到其他节点中。
  3. 退出自我保护模式   
  -   心跳续订次数又回到了预期的阙值之上
  -   禁用自我保护模式，默认情况下会启用自我保留，并且启用自我保留的默认阈值>当前注册表大小的15％。
## 五  服务提供者、服务消费者、服务发现组件的关系
  1. 服务提供者提供服务，将自身服务注册到Eureka，从而使服务消费方可以找到
  2. 服务消费者，从Eureka 获取注册服务列表，从而能够消费服务
  3. Eureka Server 提供服务注册和发现
## 六 高可用
  1. 使用集群，Eureka通过互相注册的方式来实现高可用的部署。
  1. 单节点的Eureka Server不适合线上。Eureka Client 会定时连接Eureka Server,获取服务注册表中的信息并缓存在本地。微服务在消费远程API时
     总是使用本地缓存中的数据。一般来说，即使Eureka Server发生宕机，也不会影响到服务之间的调用。但如果Eureka Server宕机时，某些微服务也出现了
     不可用的情况,Eureka Client 中的缓存若不被更新，就可能会影响到微服务的调用，甚至影响到整个应用系统的高可用性。故，在生产环境，一般都会部署
     高可用的Eureka Server集群。
  2. Eureka Server 可以通过运行多个实例并相互注册的方式实现高可用部署，Eureka Server 实例会彼此增量地同步信息，从而确保所有节点数据一致。事实
     上，节点之间互相注册是Eureka Server的默认行为。
## 七 为Eureka Server添加用户认证
  1. 在yml中添加一下代码:
   ```
   security:
      basic:
        enabled: true
      user:
        name: root
        password: root
   ```
   2. 引入依赖
   ```
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
   ```
   3. 在客户端连接的链接需要更改，添加用户名和密码
   ```
    defaultZone: http://root:root@localhost:8761/eureka/
   ```
   - 至此Eureka 添加基于Http basic的认证;对于一些比较复杂的需求，可创建一个类型为DiscoveryClientOptionalArgs的@Bean,并向其中注入ClientFilter。
## 八 Eureka 的元数据,包括标准元数据和自定义元数据
   1. 标准元数据: 主机名、IP地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。
   2. 自定义元数据: 使用eureka.instance.metadata-map 配置，这些自定义的数据可以在远程客户端中访问，但是一般不会修改客户端的行为，除非客户端清楚该元数据的意义。
## 待整理问题
  - 因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。  