# 使用静态工厂方法替代构造方法
## 一、 类获取实例的方法
  1. 提供一个公共构造方法（传统）
  2. 提供一个公共静态工厂方法
## 二、 使用静态工厂方法的优劣
### 1 优点
####  1. 有自己的名字，构造方法没有;      
  - 如果构造方法的参数本身并不描述被返回的对象，有名称的静态工厂更易于使用，易于阅读;
  - 一个类只能有一个给定签名的构造方法。如果需要多个同样签名的构造方法，只能通过修改参数类型的顺序，造成识别的困难，此时可以使用静态工厂方法。
####  2. 与构造方法不同，不需要每次调用都创建一个新的对象;
  - 表现： 允许不可变的类使用预先构建的实例或者在构造时缓存实例，提高对象的使用率，从而提高性能；
  - 静态工厂方法 重复调用返回相同对象的能力 可以使 类在任何时候存在的实例都可以严格控制。这样的类称为实例控制。   
    实例是专门类的对象（实例即对象，实例是从类的角度考虑，对象是从程序的角度考虑）   
  - 实例控制的作用:    
    1. 允许一个类来保证它是一个单例项或不可实例化的;
       - 使一个类是单例有三种方法，静态工厂方法是其中一种，如下：   
       1 公共属性方法
         ```
              public class Elvis{
                 public static final Elvis INSTANCE = new Elvis();
                 private Elvis(){...}
                 public void leaveTheBuilding(){...}
              }
         ```    
         私有构造方法只调用一次，初始化公共静态final Elvis.INSTANCE 属性。没有公共的或受保护的构造方法，保证了全局的唯一性;   
         一旦Elvis被初始化，一个Elvis的实例就会存在，仅此一个。客户端做任何事情都无法改变。但是，如果特殊存在调用AccessibleObject.setAccessible()方法，   
         以反射方式调用私有构造方法，就需要额外处理，在请求创建第二个实例时抛出异常。      
        2  静态工厂方法 
         ```
              public class Elvis{
                 private static final Elvis INSTANCE = new Elvis();
                 private Elvis(){...}
                 public static Elvis getInstance(){return INSTANCE;}
                 public void leaveTheBuilding(){...}
              }
         ```   
         所有对Elvis.getInstance 的调用都返回相同的对象引用，并且不会创建其他的Elvis实例。   
        3 以上两种方法都是基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问。   
         第一种()的优点: 1 API明确表示该类是一个单例:公共静态属性是final的，故包含相同的对象引用；2 更简单。
         第二种: 1 灵活，无论该类是否为单例而不必更改其API;返回唯一的实例，但可修改。 2 如果程序需要，可以编写一个泛型单例工厂。3 方法引用可以用   
                 supplier,例如 Elvis :: instance 等同于 Supplier<Evlist> 。除非符合这三个优点，否则选公共属性方法。
        4 值得注意的是，第三种实现方法是使用枚举类
          ```
          public enum Elvis{
             INSTANCE;
             public void leaveTheBuilding(){...}
          }
          ```
         使用枚举实现的好处是: 是实现单例的最佳方式。提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即使是在复杂的序列化或反射攻击的情况下。   
         局限性: 如果单例必须继承Enum以外的父类，就不能使用。   
            
       -  使用私有构造方法实现类的非实例化   
          一般工具类，以此实现；比如 Math 或 Arrays ;
          ```
           public class UtilityClass{
              private UtilityClass(){
                throw new AssertionError();
              }
           }
          ```
          构造方法是私有的，在类外不可访问。AssertionError异常不是严格要求的，但是它防止了客户端在类中意外地调用构造方法。保证类在任何情况下都不会被实例化。   
          缺点是： 阻止了类的子类化。所有的构造方法都必须显式或隐式地调用父类构造方法，而子类则没有可访问的父类构造方法来调用。   
          值得注意的是: 通过创建抽象类来实现类的非实例化是不行的。抽象类是可以被子类化，子类可以被实例化。而且，误导用户改类的设计是为了继承。
    > 2  允许一个不可变的值类保证不存在两个相同的实例
#### 三、 与构造方法不同，可以返回其返回类型的任何子类型的对象
#### 四、 返回对象的类可以根据输入参数的不同而不同
#### 五、 在编写包含该方法的类时，返回的对象的类不需要存在
### 缺点
#### 没有公共或受保护构造方法的类不能被子类化
#### 程序员很难找到
  